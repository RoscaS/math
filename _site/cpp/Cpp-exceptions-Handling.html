<!DOCTYPE html>
<html>

    <head>
        <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- CSS -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/cpp/Cpp-exceptions-Handling.html">
  <link rel="alternate" type="application/rss+xml" title="RoscaS" href="http://localhost:4000/feed.xml">

<!-- JS -->
  <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> -->
  <script src="/js/mermaid.min.js"></script>

</head>


        
          <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
  ga('create', 'UA-99742998-1', 'auto');
  ga('send', 'pageview');
    
	</script>


        

        
    </head>

    <body>
        <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Cpp: Exception handling (en)</title>
  <meta name="description" content="Exception handlingWhen an exception is raised (using throw), execution of the program immediately jumps to the nearest enclosing try block (propagating up th...">
</head>


        <div class="wrapper">
            <header class="post-header">
	

    <center>
		<div class="post-title" itemprop="name headline">Cpp: Exception handling (en)</div>

		<div class="post-meta"><i class="fa fa-calendar-o"></i> <time datetime="23 May 2017" itemprop="datePublished">May 23 2017</time>

			&nbsp;&nbsp;•&nbsp;&nbsp;<i class="fa fa-user-secret"></i> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Sol</span>
        	
			<br>
			<i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-pulse"></i></span>clicks</span>
		</div>

        	
        <div class="post-tags">
        	
			<a class="post-tags-item" href="http://localhost:4000/tags/">Cpp</a>
        	
			<a class="post-tags-item" href="http://localhost:4000/tags/">exceptions</a>
        	
			<a class="post-tags-item" href="http://localhost:4000/tags/">en</a>
        	
			
		</div>
    </center>

<div class="wrapper">

    <center>      
		<p>
			<a class="link" href="/">Home</a> /
			<a class="link" href="/archive/">Archive</a> /
			<a class="link" href="/category/">Category</a> / 
			<a class="link" href="/tags/">Tags</a> / 
			<a class="link" href="/about/">About</a> /
			<a class="link" href="/contact/">Contact</a>
    	</p>
    </center>
</div>
    
</header>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<div class="post-content">
    <center>
	
	<p>Theory and examples about exceptions handling</p>
	
    </center>
	<h2>Directory</h2>
</div>

<div id="category"></div>

<div class="post-content" itemprop="articleBody">
    <h1 id="exception-handling">Exception handling</h1>
<p>When an exception is raised (using <code class="highlighter-rouge">throw</code>), execution of the program immediately jumps to the nearest enclosing <code class="highlighter-rouge">try</code> block (propagating up the stack if necessary to find an enclosing <code class="highlighter-rouge">try</code> block. 
If any of the <code class="highlighter-rouge">catch</code> handlers attached to the <code class="highlighter-rouge">try</code> block handle that type of exception, that handler is executed and the exception is considered handled.</p>

<p>If no appropriate catch handlers exist, execution of the program propagates to the next enclosing <code class="highlighter-rouge">try</code> block. If no appropriate catch <code class="highlighter-rouge">handlers</code> can be found before the end of the program, <strong>the program will fail with an exception error</strong>.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// 00intro.cpp
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number"</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Can't take sqrt of neg nb"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"the sqrt of "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" is "</span>
             <span class="o">&lt;&lt;</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I have some issues with my compiler that prints trash char if I use</p>

<pre><code class="language-C++">if(x &lt; 0.0)
{
    throw ("Can't take sqrt of neg nb");
}

/// ...

catch (const char* exception)
{
    std::cerr &lt;&lt; "Error: " &lt;&lt; exception &lt;&lt; std::endl;
}

</code></pre>

<p>That’s why I use a <code class="highlighter-rouge">static_cast</code>.</p>

<h2 id="1-what-catch-blocks-typically-do">1. What catch blocks typically do</h2>

<p>If an exception is routed to a catch block, it is considered “handled” even if the catch block is empty. However, typically you’ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception:</p>

<ol>
  <li>
    <p>catch blocks may print an error (either to the console, or a log file).</p>
  </li>
  <li>
    <p>catch blocks may return a value or error code back to the caller.</p>
  </li>
  <li>
    <p>a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block – it’s handled by the next enclosing try block.</p>
  </li>
</ol>

<h2 id="2-exceptions-and-functions">2. Exceptions and functions</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">mySqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Can't take sqrt of neg nb"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter a number"</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"the sqrt of "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" is "</span>
             <span class="o">&lt;&lt;</span> <span class="n">mySqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="n">exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>output:</p>

<p><code class="highlighter-rouge">Error: Can't take sqrt of neg nb</code></p>

<p>Let’s revisit for a moment what happens when an exception is raised.</p>
<ul>
  <li>First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block).</li>
  <li>If not, the current function is terminated, and the program checks to see if the function’s caller will handle the exception.</li>
  <li>If not, it terminates the caller and checks the caller’s caller.</li>
  <li>Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled.</li>
</ul>

<p>This process is called <strong>unwinding the stack</strong>.</p>

<p>The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, “Hey, there’s a problem!”, but is unwilling to handle the problem itself.</p>

<blockquote>
  <p>Different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code.</p>
</blockquote>

<h2 id="3-catch-all">3. Catch-all</h2>

<p>Using the catch-all handler to wrap main()</p>

<p>One interesting use for the catch-all handler is to wrap the contents of main():</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">runGame</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(...)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Abnormal termination</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">saveState</span><span class="p">();</span> <span class="c1">// Save user's game
</span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind up the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user’s state before exiting. This can be useful to catch and handle problems that may be unanticipated.</p>

<h2 id="3-exception-specifiers">3. Exception specifiers</h2>

<p><strong>This subsection should be considered optional reading because exception specifiers are rarely used in practice, are not well supported by compilers, and Bjarne Stroustrup (the creator of C++) considers them a failed experiment.</strong></p>

<p>Exception specifiers are a mechanism that allows us to use a function declaration to specify whether a function may or will not throw exceptions. This can be useful in determining whether a function call needs to be put inside a try block or not.</p>

<p>There are three types of exception specifiers, all of which use what is called the throw (…) syntax.</p>

<p>First, we can use an empty throw statement to denote that a function does not throw any exceptions outside of itself:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">doSomething</span><span class="p">()</span> <span class="k">throw</span><span class="p">();</span> <span class="c1">// does not throw exceptions
</span></code></pre>
</div>
<p>Note that <code class="highlighter-rouge">doSomething()</code> can still use exceptions as long as they are handled internally. Any function that is declared with <code class="highlighter-rouge">throw()</code> is supposed to cause the program to terminate immediately if it does try to throw an exception outside of itself, but implementation is spotty.</p>

<p>Second, we can use a specific throw statement to denote that a function may throw a particular type of exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">doSomething</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="c1">// may throw a double
</span></code></pre>
</div>

<p>Finally, we can use a catch-all throw statement to denote that a function may throw an unspecified type of exception:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">doSomething</span><span class="p">()</span> <span class="k">throw</span><span class="p">(...);</span> <span class="c1">// may throw anything
</span></code></pre>
</div>

<p>Due to the incomplete compiler implementation, the fact that exception specifiers are more like statements of intent than guarantees, some incompatibility with template functions, and the fact that most C++ programmers are unaware of their existence, I recommend you do not bother using exception</p>

<h2 id="4-exceptions-and-member-functions">4. Exceptions and member functions</h2>

<h3 id="overloaded-operators">Overloaded operators</h3>

<p>Overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or boolean values to the caller. However, since exceptions do not change the signature of a function, they can be put to great use here. Here’s an example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span><span class="o">&amp;</span> <span class="n">IntArray</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">getLength</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">m_data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Now, if the user passes in an invalid index, operator[] will throw an int exception.</p>

<h3 id="constructors">Constructors</h3>

<p>Constructors are another area of classes in which exceptions can be very useful. If a constructor fails, simply throw an exception to indicate the object failed to create. <strong>The object’s construction is aborted</strong> and its <strong>destructor is never executed</strong> (note: this means your exception handler should <strong>handle any necessary cleanup</strong>).</p>

<h2 id="5-exception-class">5. Exception class</h2>
<p>An exception class is just a normal class that is designed specifically to be thrown as an exception.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArrayException</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_error</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayException</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">getError</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_error</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntArray</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    
<span class="k">public</span><span class="o">:</span>
    <span class="n">IntArray</span><span class="p">(){}</span>
    <span class="kt">int</span> <span class="n">getLenght</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">getLenght</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">ArrayException</span><span class="p">(</span><span class="s">"Invalid index"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">IntArray</span> <span class="n">a1</span><span class="p">;</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">ArrayException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"An array exception occured ("</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">getError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish.</p>

<p>Note that exception handlers should catch class exception objects by <strong>reference</strong> instead of by value. This prevents the compiler from making a copy of the exception, which can be <strong>expensive</strong> when the exception is a class object, and <strong>prevents object slicing</strong> when dealing with derived exception classes. Catching exceptions by <strong>pointer should generally be avoided</strong> unless you have a specific reason to do so.</p>

<h2 id="6-exceptions-and-inheritance">6. Exceptions and inheritance</h2>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">Derived</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"caught Base"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Derived</span> <span class="o">&amp;</span><span class="n">derived</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"caught Derived"</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	
</code></pre>
</div>

<p>output:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>caught Base
</code></pre>
</div>

<p>Derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so <strong>sequentially</strong>. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case.</p>

<p>In order to make this example work as expected, we need to flip the order of the catch blocks:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
 
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">Derived</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Derived</span> <span class="o">&amp;</span><span class="n">derived</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"caught Derived"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"caught Base"</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>	
</code></pre>
</div>
<p>This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will “fall through” to the Base handler.</p>

<blockquote>
  <p><strong>Rule: Handlers for derived exception classes should be listed before those for base classes.</strong></p>
</blockquote>

<blockquote>
  <p>The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful.</p>
</blockquote>

<h2 id="7-stdexception">7. std::exception</h2>

<p>Many of the classes and operators in the standard library throw exceptions classes on failure. For example, operator new and std::string can throw std::bad_alloc if they are unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast.</p>

<p>All of these exception classes are derived from a single class called std::exception. std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library.</p>

<blockquote>
  <p>Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we’ll end up catching std::exception and all (21+) of the derived exceptions together in one place. Easy!</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;exception&gt;
#include&lt;string&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// code with standard library goes here
</span>        <span class="c1">// We'll trigger one of these exception...
</span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// will trigger a std::bad_alloc
</span>    <span class="p">}</span>
    <span class="c1">// this handler will catch std::exception and all the
</span>    <span class="c1">// ferived exceptions too
</span>    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Standard exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The above program prints:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Standard exception: string too long
</code></pre>
</div>

<p><code class="highlighter-rouge">std::exception</code> has a virtual member function named <code class="highlighter-rouge">what()</code> that returns a C-style string description of the exception. Most derived classes override the <code class="highlighter-rouge">what()</code> function to change the message. Note that this string is meant to be used for descriptive text only – <strong>do not use it for comparisons</strong>, as it is not guaranteed to be the same across compilers.</p>

<p>Sometimes we’ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others “fall through” to the base handler. Consider:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    
<span class="p">}</span>
<span class="c1">// This handler will catch std::bad_alloc 
// (and any exceptions derived from it) here
</span><span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"You ran out of memory! "</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Standard exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In this example, exceptions of type std::bad_alloc will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler.</p>

<p>Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don’t have to do too much work to catch “everything else” in a hierarchy.</p>

<h2 id="8-using-the-standard-exceptions-directly">8. Using the standard exceptions directly</h2>

<p>Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. <a href="http://en.cppreference.com/w/cpp/error/exception">cppreference</a></p>

<blockquote>
  <ul>
    <li>logic_error
      <ul>
        <li>invalid_argument</li>
        <li>domain_error</li>
        <li>length_error</li>
        <li>out_of_range</li>
        <li>future_error(C++11)</li>
        <li>bad_optional_access(C++17)</li>
      </ul>
    </li>
    <li>runtime_error
      <ul>
        <li>range_error</li>
        <li>overflow_error</li>
        <li>underflow_error</li>
        <li>regex_error(C++11)</li>
        <li>tx_exception(TM TS)</li>
        <li>system_error(C++11)
          <ul>
            <li>ios_base::failure(C++11)</li>
            <li>filesystem::filesystem_error(C++17)</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>bad_typeid</li>
    <li>bad_cast
      <ul>
        <li>bad_any_cast(C++17)</li>
      </ul>
    </li>
    <li>bad_weak_ptr(C++11)</li>
    <li>bad_function_call(C++11)</li>
    <li>bad_alloc
      <ul>
        <li>bad_array_new_length(C++11)</li>
      </ul>
    </li>
    <li>bad_exception</li>
    <li>ios_base::failure(until C++11)</li>
    <li>bad_variant_access(C++17)</li>
  </ul>
</blockquote>

<p><code class="highlighter-rouge">std::runtime_error</code> (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">try</span>
	<span class="p">{</span>
		<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Bad things happened"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">// This handler will catch std::exception and all the derived exceptions too
</span>	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Standard exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This prints:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Standard exception: Bad things happened
</code></pre>
</div>

<h2 id="9-deriving-your-own-classes-from-stdexception">9. Deriving your own classes from std::exception</h2>

<p>You can derive your own classes from <code class="highlighter-rouge">std::exception</code>, and override the virtual <code class="highlighter-rouge">what()</code> member function. Here’s the same program as above, with <code class="highlighter-rouge">ArrayException</code> derived from <code class="highlighter-rouge">std::exception</code>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;exception&gt;
</span>
<span class="k">class</span> <span class="nc">ArrayException</span> <span class="o">:</span><span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_error</span><span class="p">;</span>
    
<span class="k">public</span><span class="o">:</span>
    <span class="n">ArrayException</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">error</span><span class="p">)</span><span class="o">:</span> <span class="n">_error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{}</span>
    <span class="c1">// return the std::string as a const C-style string
</span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_error</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">IntArray</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">IntArray</span><span class="p">(){}</span>
    <span class="kt">int</span> <span class="n">getLenght</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">getLenght</span><span class="p">())</span>
            <span class="k">throw</span> <span class="n">ArrayException</span><span class="p">(</span><span class="s">"invalid index"</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">IntArray</span> <span class="n">a1</span><span class="p">;</span> 
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// derived catch block go first !!
</span>    <span class="k">catch</span> <span class="p">(</span><span class="n">ArrayException</span> <span class="o">&amp;</span> <span class="n">exception</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"An array exception occured ("</span> 
                  <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">exception</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Some other std::exception occured ("</span> 
                  <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It’s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception. All are valid approaches depending on your aims.</p>

<h2 id="rethrowing-an-exception">Rethrowing an exception</h2>
<p>http://www.learncpp.com/cpp-tutorial/14-6-rethrowing-exceptions/</p>

<h2 id="10-function-try-blocks">10. Function try blocks</h2>

<p>Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>    
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="mi">1</span><span class="p">;}</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span><span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// what happens if creation of A fails and
</span>        <span class="c1">// we want to handle it here?
</span>    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Oops</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main’s try block will catch it. Consequently, this program prints:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Oops
</code></pre>
</div>

<p>But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor’s body is called. There’s no way to wrap a standard try block around it.</p>

<p>In this situation, we have to use a slightly modified try block called a <strong>function try block</strong>.</p>

<p>Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>    
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="mi">1</span><span class="p">;}</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span><span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">try</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">// note addition of try keyword
</span>    <span class="p">{}</span> 
    <span class="k">catch</span> <span class="p">(...)</span> <span class="c1">// note this is at same level of indendation 
</span>    <span class="p">{</span>           <span class="c1">// as the function itself
</span>
     <span class="c1">// exceptions from member initializer list or constructor
</span>     <span class="c1">// body are cought here
</span>     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Construction of A failed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>   
     <span class="c1">// if an exception isn't explicitly thrown here, the curent
</span>     <span class="c1">// exception will be implicitly rethrown
</span>    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Oops</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>When this program is run, it produces the output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Construction of A failed
Oops
</code></pre>
</div>
<p>Let’s examine this program in more detail.</p>

<p>First, note the addition of the “try” keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block.</p>

<p>Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here.</p>

<p>Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack.</p>

<p>In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints “Oops”!</p>

<p>Although function level try blocks can be used with non-member functions as well, they typically aren’t because there’s rarely a case where this would be needed. <strong>They are almost exclusive used with derived constructors</strong>!</p>

<h2 id="11-exception-dangers-and-downsides">11. Exception dangers and downsides</h2>

<h3 id="cleaning-up-resources">Cleaning up resources</h3>

<p>One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="n">openFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
    <span class="n">writeFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">closeFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">FileException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to write to file: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What happens if WriteFile() fails and throws a FileException? At this point, we’ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="n">openFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
    <span class="n">writeFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">closeFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">FileException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure file is closed
</span>    <span class="n">closeFile</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
    <span class="c1">// Then write error
</span>    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to write to file: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This kind of error often crops up in another form when dealing with dynamically allocated memory:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="n">Person</span> <span class="o">*</span><span class="n">john</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">"John"</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">PERSON_MALE</span><span class="p">);</span>
    <span class="n">processPerson</span><span class="p">(</span><span class="n">john</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">john</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">PersonException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to process person: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If <code class="highlighter-rouge">processPerson()</code> throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one – because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there’s no way for it to deallocate the memory.</p>

<p>However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">Person</span> <span class="o">*</span><span class="n">john</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">john</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">"John"</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">PERSON_MALE</span><span class="p">);</span>
    <span class="n">processPerson</span><span class="p">(</span><span class="n">john</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">john</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">PersonException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">john</span><span class="p">;</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to process person: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly.</p>

<p>The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a “smart pointer”. The standard library provides a class called <strong>std::unique_ptr</strong> that can be used for this purpose. std::unique_ptr is a template class that holds a pointer, and deallocates it when it goes out of scope.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;; // for std::unique_ptr
</span> 
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">Person</span> <span class="o">*</span><span class="n">john</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">"John"</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="n">PERSON_MALE</span><span class="p">);</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">upJohn</span><span class="p">(</span><span class="n">john</span><span class="p">);</span> <span class="c1">// upJohn now owns john
</span> 
    <span class="n">ProcessPerson</span><span class="p">(</span><span class="n">john</span><span class="p">);</span>
 
    <span class="c1">// when upJohn goes out of scope, it will delete john
</span><span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">PersonException</span> <span class="o">&amp;</span><span class="n">exception</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to process person: "</span> <span class="o">&lt;&lt;</span> <span class="n">exception</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="exceptions-and-destructors">Exceptions and destructors</h3>

<p>Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should never be thrown in destructors.</p>

<p>The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn’t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately.</p>

<p>Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead.</p>

<h3 id="performance-concerns">Performance concerns</h3>

<p>Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation. Consequently, exception handling is best used for truly exceptional cases and catastrophic errors, not for routine error handling.</p>

<p>As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found.</p>

<p><a href="http://www.learncpp.com/cpp-tutorial/141-the-need-for-exceptions/">learncpp.com</a></p>

<h2 id="12-exercise">12. Exercise:</h2>

<p>1) Write a Fraction class that has a constructor that takes a numerator and a denominator. If the user passes in a denominator of 0, throw an exception of type std::runtime_error (included in the stdexcept header). In your main program, ask the user to enter two integers. If the Fraction is valid, print the fraction. If the Fraction is invalid, catch a std::exception, and tell the user that they entered an invalid fraction.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;stdexcept&gt;
</span>
<span class="k">class</span> <span class="nc">Fraction</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_den</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Fraction</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">Fraction</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">den</span><span class="p">)</span><span class="o">:</span> <span class="n">_num</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">_den</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">den</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Invalid denominator"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span>
    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">Fraction</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">_num</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">_den</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Numerator: "</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numerator</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">numerator</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Denominator: "</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">denominator</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">denominator</span><span class="p">;</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">Fraction</span> <span class="n">f</span><span class="p">{</span><span class="n">numerator</span><span class="p">,</span><span class="n">denominator</span><span class="p">};</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Your fraction is: "</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Standard exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

</div>

<div>
	
	<div class="tbc"></div>
	
</div>

<!--<div class="share">
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=Cpp: Exception handling (en)@&amp;url=http://localhost:4000/cpp/Cpp-exceptions-Handling.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/cpp/Cpp-exceptions-Handling.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://plus.google.com/share?url=http://localhost:4000/cpp/Cpp-exceptions-Handling.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>
-->

<div id="disqus_thread"></div>


 
</div>


</article>

        </div>

    </body>

<footer class="site-footer">
    <div class="wrapper">
        <center>
            <p>
                <a class="link" href="/%20/">Home</a> /
                <a class="link" href="/archive/">Archive</a> /
                <a class="link" href="/category/">Category</a> /
                <a class="link" href="/tags/">Tags</a> /
                <a class="link" href="/about/">About</a> /
                <a class="link" href="/contact/">Contact</a>
            </p>
            <span><script>document.write(new Date().getFullYear());</script></span>
            <span>&copy;</span>

            <a href="mailto:sol.rosca@gmail.com?subject=Hello&nbsp;RoscaS"> RoscaS</a>
            <br>
        </center>
    </div>
</footer>

<foot>
    <foot>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Derictory -->

  <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
  <script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>

<!-- Hit analytics -->

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- Directory -->

<script src="/js/main.js"></script>

</foot>

</foot>

</html>
