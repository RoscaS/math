<!DOCTYPE html>
<html>

    <head>
        <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- CSS -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/cpp/cpp-SmartPtr.html">
  <link rel="alternate" type="application/rss+xml" title="RoscaS" href="http://localhost:4000/feed.xml">

<!-- JS -->
  <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> -->
  <script src="/js/mermaid.min.js"></script>

</head>


        
          <script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
  ga('create', 'UA-99742998-1', 'auto');
  ga('send', 'pageview');
    
	</script>


        

        
    </head>

    <body>
        <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Cpp: unique_ptr &amp; shared_ptr</title>
  <meta name="description" content="Lecture utile avant de se lancer dans ce poste">
</head>


        <div class="wrapper">
            <header class="post-header">
	

    <center>
		<div class="post-title" itemprop="name headline">Cpp: unique_ptr & shared_ptr</div>

		<div class="post-meta"><i class="fa fa-calendar-o"></i> <time datetime="22 Jun 2017" itemprop="datePublished">Jun 22 2017</time>

			&nbsp;&nbsp;•&nbsp;&nbsp;<i class="fa fa-user-secret"></i> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Sol</span>
        	
			<br>
			<i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-pulse"></i></span>clicks</span>
		</div>

        	
        <div class="post-tags">
        	
			<a class="post-tags-item" href="http://localhost:4000/tags/">cpp</a>
        	
			
		</div>
    </center>

<div class="wrapper">

    <center>      
		<p>
			<a class="link" href="/">Home</a> /
			<a class="link" href="/archive/">Archive</a> /
			<a class="link" href="/category/">Category</a> / 
			<a class="link" href="/tags/">Tags</a> / 
			<a class="link" href="/about/">About</a> /
			<a class="link" href="/contact/">Contact</a>
    	</p>
    </center>
</div>
    
</header>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
<div class="post-content">
    <center>
	
    </center>
	<h2>Directory</h2>
</div>

<div id="category"></div>

<div class="post-content" itemprop="articleBody">
    <h3 id="lecture-utile-avant-de-se-lancer-dans-ce-poste">Lecture utile avant de se lancer dans ce poste</h3>

<ul>
  <li><a href="\cpp\cpp-R-value-L-value.html">L-value et R-value</a></li>
  <li><a href="\cpp\cpp-semantiqueCopie.html">Sémantique de copie</a></li>
  <li><a href="\cpp\cpp-move&amp;smartP.html">Sémantique de déplacement</a><br />
Ce dernier point est un prérequis plus qu’un conseil.</li>
</ul>

<h3 id="sources">sources</h3>

<ul>
  <li><a href="http://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/">learncpp.com</a> (ch 15.1 à 15.7)</li>
  <li><a href="https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">Herb Sutter’s blog GotW #89</a></li>
  <li><a href="https://stackoverflow.com/">stackoverflow</a></li>
  <li><a href="https://www.tutorialspoint.com">tutorialsPoint</a></li>
  <li><a href="https://fr.wikipedia.org/">wikipedia</a></li>
</ul>

<h2 id="stdunique_ptr">std::unique_ptr</h2>

<p>Au début de <a href="\cpp\cpp-move&amp;smartP.html">cet</a> article nous avons vu les dangers de l’utilisation des pointeurs. Après y avoir également couvert les bases de la sémantique de déplacement, nous pouvons maintenant tenter de cerner les smart pointers.</p>

<h3 id="rappel">rappel</h3>

<blockquote>
  <p>Un smart ponter est une classe qui gère (possède, own) un objet alloué dynamiquement et s’assure que l’objet est est proprement néttoyé en fin de vie (généralement quand il sort de portée).</p>

  <p>À cause de cette propriété, un smart pointeur <strong>ne doit jamais</strong> être lui même dynamiquement alloué. Si c’était le cas, tout le mécanisme de gestion serait saboté et on se retrouverait à coup sur avec des fuites de mémoire. Si l’allocation est toujours faite statiquement (en tant que variable locale où “composition member of a class”), il est garantis que le smart pointer se retrouvera lui même hors de portée lorsque l’objet qu’il contient se retrouvera hors de portée assurant le néttoyage de la ressource et du smart pointer.</p>
</blockquote>

<p>La librairie de C++ 11 possède 4 types de smart pointer:</p>
<ul>
  <li><code class="highlighter-rouge">std::auto_ptr</code> à fuir comme la peste (sera retiré à la révision 17)</li>
  <li><code class="highlighter-rouge">std::unique_ptr</code> qui remplace efficacement le précédent et le plus utilisé des 4</li>
  <li><code class="highlighter-rouge">std::shared_ptr</code></li>
  <li><code class="highlighter-rouge">std::weak_ptr</code></li>
</ul>

<h3 id="stdunique_ptr-1">std::unique_ptr</h3>

<p>Utilisé pour gérer dynamiquement un objet alloué dynamiquement mais dont unique_ptr est le seul possésseur.</p>

<p><code class="highlighter-rouge">std::unique_ptr</code> vit dans les header <code class="highlighter-rouge">memory</code></p>

<p>Considérons cet exemple:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;memory&gt;    // pour std::unique_ptr
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource détruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res1</span><span class="p">(</span><span class="k">new</span> <span class="n">Ressource</span><span class="p">);</span> <span class="c1">// Ressource créé ici
</span>	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res2</span><span class="p">;</span> <span class="c1">// commence comme nullptr
</span> 

    <span class="c1">// res2 = res1; // ne compilera pas: affectation par copie disabled
</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"res1 est"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span> <span class="o">?</span> <span class="s">"non null</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"null</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"res2 est"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span> <span class="o">?</span> <span class="s">"non null</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"null</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 
	<span class="n">res2</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">res1</span><span class="p">);</span> <span class="c1">// res2 reprend l'ownership, res1 est set à null
</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ownership transferred</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"res1 est"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span> <span class="o">?</span> <span class="s">"non null</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"null</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"res2 est"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span> <span class="o">?</span> <span class="s">"non null</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"null</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Comme <code class="highlighter-rouge">unique_ptr</code> a été conçu avec la sémantique de déplacement en tête, si nous voulons transférer l’ownership d’un unique_ptr à un autre nous <strong>devons</strong> utiliser la sémantique de déplacement. Dans l’exemple plus haut nous faisons ça via la fonction <code class="highlighter-rouge">std::move()</code> qui converti res1 en R-value et force l’utilisation de la sémantique de déplacement.</p>

<h3 id="accès-aux-membres">Accès aux membres</h3>

<p>Comme les pointeurs traditionnels:</p>

<ul>
  <li><code class="highlighter-rouge">*</code> retourne une référence de la ressource possédée</li>
  <li><code class="highlighter-rouge">-&gt;</code> retourne un pointeur sur la ressource possédée</li>
</ul>

<blockquote>
  <p>Il est important de garder en tête que pour de multiples raisons unique_ptr peut ne pas posséder de ressource !</p>
</blockquote>

<p>Si nous castons un unique_ptr en bool il renvoie true si il possède une ressource (false daans le cas contraire) comme dans l’exemple suivant:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource détruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ressource</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"Je suis une ressource</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="k">new</span> <span class="n">Ressource</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">){</span> <span class="c1">// cast implicite vers bool pour assurer la possession
</span>             <span class="c1">// de ressource 
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span> <span class="c1">// print la ressource possédée par res.
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Ressource acquise
Je suis une ressource
Ressource détruite
</code></pre>
</div>

<h3 id="stdunique_ptr-et-tableaux">std::unique_ptr et tableaux</h3>

<p>unique_ptr gère très bien le delete de tableaux (delete []), il n’y a aucun problème pour l’utiliser dans ce contexte. Celà dit dans presque tous les cas <strong>il est préférable d’utiliser les classes std::vector ou std::array qu’un smart pointer et un tableau classique !</strong></p>

<h4 id="règle">Règle</h4>
<p><span style="color:red">Favoriser l’utilisation de std::vector, std::array ou std::string sur l’utilisation d’unique_ptr avec un tableau fixe ou dynamique.</span></p>

<h3 id="stdmake_unique-c-14">std::make_unique (C++ 14)</h3>

<p>C++14 apporte une nouvelle fonction <code class="highlighter-rouge">std::make_unique()</code>. Cette fonction template construit un objet du type spécifié et l’initialise avec les arguments passé à la fonction.</p>

<p><span style="color:red">pas d’initialisation uniforme possible ! </span></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Fraction</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">_den</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 
<span class="k">public</span><span class="o">:</span>
	<span class="n">Fraction</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">:</span> <span class="n">_num</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">_den</span><span class="p">(</span><span class="n">den</span><span class="p">)</span> <span class="p">{}</span>
 
	<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Fraction</span> <span class="o">&amp;</span><span class="n">f1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">.</span><span class="n">_num</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">.</span><span class="n">_den</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
 
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// crée UNE fraction allouée dynamiquement (3/5)
</span>	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">f1</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
 
    <span class="c1">// crée un tableu dynamique de fractions de longueur 4
</span>    <span class="c1">// on peut aussi utiliser auto pour faciliter encore plus
</span>	<span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Fraction</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
 
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>3/5
0/1
</code></pre>
</div>

<p>L’utilisation de std::make_unique() est optionelle mais à privilégier.<br />
<a href="http://www.learncpp.com/cpp-tutorial/15-5-stdunique_ptr/">plus d’info</a></p>

<h3 id="unique_ptr-en-retour-de-fonction">unique_ptr en retour de fonction</h3>

<p>Aucun soucis de ce coté…</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">creeRessource</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">creeRessource</span><span class="p">();</span>
    <span class="c1">// fait qqch
</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Dans ce code, creeRessource() retourne un objet unique_ptr par valeur. Si cette valeur n’est pas attribuée, l’objet t’emporaire se retrouvera hors porté et sera néttoyé ainsi que la ressource qu’il contient. Si assigné, comme dans notre cas, la sémantique de déplacement est utilisée pour le retour. Ce qui en fait un moyen bien plus safe pour retourner des valeurs qu’un pointeur traditionnel.</p>

<h4 id="règle-1">Règle</h4>
<p><span style="color:red">Ne jamais retourner un unique_ptr par référence ou par pointeur à moins d’avoir une raison spécifique de le faire !</span></p>

<h3 id="passer-un-unique_ptr-à-une-fonction">Passer un unique_ptr à une fonction</h3>
<p>Si nous voulons passer un un unique_ptr à une fonction sans perdre la possession de l’objet, on la passe par référence <span style="color:red">const</span></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource détruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ressource</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"Je suis une ressource</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">utiliseRessource</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">utiliseRessource</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ressource détruite ici
</span><span class="p">}</span>

</code></pre>
</div>

<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Ressource acquise
Je suis une ressource

Fin
Ressource détruite
</code></pre>
</div>

<p>Si au contraire, nous voulons que la fonction prènne la possession de l’objet, nous passons le unique_ptr par valeur mais attention à utiliser un <code class="highlighter-rouge">std::move</code> car la sémentique de déplacement ne joue plus.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">prendPossession</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>   
<span class="p">}</span> <span class="c1">// la ressource est détruite ici
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="c1">// prendPossession(ptr) // ne fonctionne pas, on doit forcer
</span>                            <span class="c1">// la sémantique de déplacement
</span>
    <span class="n">prendPossession</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span> <span class="c1">// ok !
</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>

<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Ressource acquise
Je suis une ressource

Ressource détruite
Fin
</code></pre>
</div>

<p>Bien noter que dans ce cas la posssession a été transfefée à prendPossession() et que la ressource à été détruite à la fin du contexte de la fonction et non pas à la fin du main.</p>

<h3 id="mauvais-usage-dunique_ptr">Mauvais usage d’unique_ptr</h3>

<p>Il existe deux façons de chier dans la colle en utilisant unique_ptr. Ces deux façons sont faciles à éviter.</p>

<ol>
  <li>Ne pas laisser de multiples classes gérer la même ressource:
    <div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Ressource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Resource</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res2</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</code></pre>
    </div>
  </li>
</ol>

<p>Même si la syntaxe est légale, le résultat sera que <code class="highlighter-rouge">res1</code> et <code class="highlighter-rouge">res2</code> vont tenter de delete la Ressource ce qui est biensur une sitation à éviter!</p>

<ol>
  <li>Ne pas delete manuellement la ressource encapsulée dans unique_ptr.</li>
</ol>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Ressource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ressource</span><span class="p">;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">res1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">res</span><span class="p">;</span>
</code></pre>
</div>
<p>La situation est semblable à la première et aura les mêmes conséquences.</p>

<p><span style="color:green">A noter que la fonction <code class="highlighter-rouge">std::make_unique()</code> empèche ces deux situations de se produire  par accident!!</span></p>

<h2 id="stdshared_ptr">std::shared_ptr</h2>

<p>Contrairement à unique_ptr qui est fait pour ne posséder qu’une ressource, shared_pointer est fait pour gérer les cas où nous avons besoin de plusieurs smart pointer qui possède la même ressource.</p>

<p>shared_ptr garde de façon interne trace des du nombre d’autres shared_ptr qui possède une même ressource.</p>

<p>Tant qu’il y a au moins un shared_ptr qui possède une la ressource, cette dernière ne sera pas désaoullée même si d’autres shared_ptr sont détruits.</p>

<p>Aussitôt que le dernier shared_ptr possèdant la ressource pase hors portée (ou est réassignée …), la ressource est désaoullée.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;memory&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource détruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// alloue une ressource et la donne au shared_ptr
</span>    <span class="n">Ressource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ressource</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span> <span class="c1">// initialisation par
</span>        <span class="c1">// copie du premier shared_ptr
</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du premier shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// ptr2 sors de portée ici mais rien ne se passe
</span>    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du second shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 sors de portée ici et les ressources allouées sont
// détruites.
</span></code></pre>
</div>

<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Ressource acquise
Fin de context du premier shared_Ptr
Fin de context du second shared_Ptr
Ressource détruite
</code></pre>
</div>

<p>Noter qu’on a créé le second shared_ptr en copiant le premier shared_ptr. <span style="color:red"> Ceci est important ! </span> Considérons le code suivant:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// alloue une ressource et la donne au shared_ptr
</span>    <span class="n">Ressource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ressource</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">res</span><span class="p">);</span> <span class="c1">// cree ptr2 directement
</span>        <span class="c1">// à partir de la ressource (et non pas ptr1);
</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du premier shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// ptr2 sors de portée ici et les ressources sont détruites
</span>    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du second shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 sors de portée ici et les ressources allouées sont
// détruites... encore CRASH !
</span></code></pre>
</div>

<p>Crash !</p>

<p>La différence est ici que nous créons deux shared_ptr indépendant l’un de l’autre. Malgré qu’ils pointent tous les deux sur la même ressource, ils n’en ont pas conscience et quand ptr2 sors de portée, il pense être le seul à posséder cette ressource et la détruit. Une fois que ptr1 sors de portée, il re-détruit les ressources et celà entraine donc un crash.</p>

<p>Cette situation est facile à éviter en gardant en tête d’utiliser un cstr de copie ou un opérateur d’affectation quand nous voulons utiliser plusieurs shared_ptr sur la même ressource.</p>

<h4 id="règle-2">Règle</h4>

<p><span style="color:red"> Toujours faire une copie d’un shared_ptr déja éxistant quand on a besoin de plus d’un shared_pointer pointant sur la même ressource.  </span></p>

<h3 id="stdmake_shared">std::make_shared</h3>

<p>De la même façon que <code class="highlighter-rouge">std::make_unique()</code> nous permet de créér un un unique_ptr, make_shared peut (et devrait) être utilisé pour créér un shared_ptr.</p>

<p>Reprenons le précédent exemple en utilisant make_shared:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
#include&lt;memory&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource détruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// alloue une ressource et possédée par shared_ptr
</span>    <span class="k">auto</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span> <span class="c1">// crée ptr2 en utilisant le cstr de copie
</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du premier shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// ptr2 sors de portée ici et rien ne se passe
</span>    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin de context du second shared_Ptr</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// ptr1 sors de portée ici et les ressources allouées sont détruites
</span>
</code></pre>
</div>

<p><span style="color:red">Il est plus performant d’utiliser make_shared que de créér un pointeur avec new et d’ensuite le passer a shared_ptr.</span></p>

<h3 id="conversion-unique--rightarrow--shared">Conversion unique $ \rightarrow $ shared</h3>

<p>Un des constructeurs de shared_ptr permet transformer un unique_ptr en shared_ptr.</p>

<p><span style="color:red"> L’inverse n’est pas possible. </span></p>

<h2 id="en-bref">En bref</h2>

<ul>
  <li>
    <p>Un smart pointer est une classe qui permet d’assurer que la mémoire dynamiquement allouée à un objet soie libérée quand l’objet se retrouve hors de son contexte d’utilisation.</p>
  </li>
  <li>
    <p>La sémantique de copie permet à un objet d’une classe d’être copié. Ceci est réalisé à l’aide du constructeur de copie et de l’opérateur d’affectation (surcharge copie).</p>
  </li>
  <li>
    <p>La sémantique de déplacement permet à un objet d’être tranféré d’un possésseur à un autre à la place d’en faire une copie couteuse. Ceci est réalisé à l’aide du constructeur de déplacement et de l’opérateur d’affectation (surcharge déplacement).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::auto_ptr</code> est déprécié et ne doit pas être utilisé.</p>
  </li>
  <li>
    <p>Une référence sur une R-value est une référence qui est faite pour être initialisée avec une R-value. La syntaxe pour créér une tel référence implique deux esperluettes (&amp;&amp;). On peut créér des fonctions qui prennent des références à des R-value en paramètre mais nous ne devrions que très rarement retourner des références sur des R-value.</p>
  </li>
  <li>
    <p>Si nous construisons un objet ou faisons une affectation dont l’argument est une L-value, il vaut dans la plus part des cas mieux <strong>copier</strong> (et non pas déplacer) la L-value. On ne peut pas assumer le fait que cette L-value sera modifié quelque part dans la suite du programme. Dans l’expressions <code class="highlighter-rouge">a = b</code> il est évident que <code class="highlighter-rouge">b</code> ne subira aucune modification.</p>
  </li>
  <li>
    <p>Quand nous construisons un objet ou faisons une affectation dont l’argument est une R-value, nous savons que cette R-value n’est d’une certaine façon qu’un objet temporaire. À la place de faire une couteuse copie, nous pouvons transférer les ressours à l’objet que nous construisons ou affectons. C’est une procédure safe car de toutes façon l’objet temporaire sera détruit à la fin du contexte et ne sera plus utilisé plus lui loin dans le programme.</p>
  </li>
  <li>
    <p>Nous pouvons utiliser le mot clé <code class="highlighter-rouge">delete</code> pour <em>disable</em> la sémantique de copie dans les classes que nous créons en settant <code class="highlighter-rouge">= delete</code> dans le header du constructeur de copie et de la surcharge de l’opperateur d’affectation.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::move()</code> nous permet de traiter une L-value comme étant une R-value. C’est utile quand nous voulons forcer la sémantique de déplacement à la sémentique de copie dans le cas d’une L-value</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::unique_ptr</code> est la classe de smart pointer que nous devrions utiliser. Elle possède une seul ressource non partageable.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::make_unique()</code> (C++14) devrait être favorisée sur l’utilisation de new pour la création d’un <code class="highlighter-rouge">std::unique_ptr</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::unique_ptr</code> <em>disable</em> la sémantique de copie</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::shared_ptr</code> est la classe de smart pointer à utiliser quand nous avons besoin que plusieurs objets accèdent à la même ressource. La ressource ne sera détruite que lorsque le dernier <code class="highlighter-rouge">std::shared_ptr</code> qui la possède sera hors contexte.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::make_shared()</code> devrait être favorisé pour créér de nouveaus <code class="highlighter-rouge">std::shared_ptr</code>.</p>
  </li>
  <li>
    <p>avec <code class="highlighter-rouge">std::shared_ptr</code> la sémantique de copie <strong>doit</strong> être utilisée pour créér un pointeur supplémentaire pointant sur le même objet.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">std::weak_ptr</code> est la classe de smart pointer à utiliser quand on a besoin d’un ou plusieurs objets capable de voir et d’accéder à une ressource possédée par un <code class="highlighter-rouge">std::shared_ptr</code> mais qui n’a pas d’influance sur la destruction de la ressource.</p>
  </li>
</ul>

<h2 id="exemples-pratiques">Exemples pratiques</h2>

<h3 id="shared_ptr-et-make_shared">shared_ptr et make_shared</h3>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource detruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">poke</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Poked!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>
        <span class="p">{</span>
            <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="n">ptr2</span><span class="p">{</span><span class="n">ptr1</span><span class="p">};</span>
                <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>  
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sortie contexte ptr2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ressource toujours accessible par ptr1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sortie contexte ptr1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>output:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Ressource acquise
	Poked!
	Poked!
sortie contexte ptr2
ressource toujours accessible par ptr1
	Poked!
Ressource detruite
sortie contexte ptr1
</code></pre>
</div>

<h3 id="mot-clé-auto">mot clé auto</h3>

<p>Le code suivant est équivalent au précédent mais plus court</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Ressource</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource acquise</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">Ressource</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ressource detruite</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">poke</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Poked!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Ressource</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>
        <span class="p">{</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span> 
                <span class="k">auto</span> <span class="n">ptr3</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>  <span class="c1">// equivalent !
</span>                <span class="c1">// auto ptr4{ptr1}; // mot clé auto -&gt; pas de { ... }
</span>                <span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>  
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sortie contexte ptr2</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ressource toujours accessible par ptr1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">poke</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sortie contexte ptr1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p><span style="color:red"> Si nous utilisons le mot clé <code class="highlighter-rouge">auto</code> nous ne pouvons pas utiliser l’initialisation uniforme ! </span>
<a href="\cpp\cpp-Divers.html">Plus d’info</a></p>

<h2 id="quiz-learncppcom">Quiz <a href="http://www.learncpp.com/cpp-tutorial/15-x-chapter-15-comprehensive-review/">learncpp.com</a>:</h2>

<h4 id="1-explain-when-you-should-use-the-following-types-of-pointers">1. Explain when you should use the following types of pointers:</h4>

<ul>
  <li>std::unique_ptr</li>
</ul>

<p>std::unique_ptr should be used when you want a smart pointer to manage a dynamic object that is not going to be shared.</p>

<ul>
  <li>std::shared_ptr</li>
</ul>

<p>std::shared_ptr should be used when you want a smart pointer to manage a dynamic object that may be shared. The object won’t be deallocated until all std::shared_ptr holding the object are destroyed.</p>

<ul>
  <li>std::weak_ptr</li>
</ul>

<p>std::weak_ptr should be used when you want access to an object that is being managed by a std::shared_ptr, but don’t want the lifetime of the std::shared_ptr to be tied to the lifetime of the std::weak_ptr.</p>

<ul>
  <li>std::auto_ptr</li>
</ul>

<p>std::auto_ptr is deprecated and slated for removal in C++17. It should not be used.</p>

<h4 id="2-explain-how-r-values-references-enable-move-semantics">2. Explain how r-values references enable move semantics.</h4>

<p>Because r-values are temporary, we know they are going to get destroyed after they are used. When passing or return an r-value by value, it’s wasteful to make a copy and then destroy the original. Instead, we can simply move (steal) the r-value’s resources, which is generally more efficient.</p>

</div>

<div>
	
	<div class="tbc"></div>
	
</div>

<!--<div class="share">
    <p>Share this post with: </p>
	<a href="https://twitter.com/intent/tweet?text=Cpp: unique_ptr & shared_ptr@&amp;url=http://localhost:4000/cpp/cpp-SmartPtr.html" class="twitter-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/cpp/cpp-SmartPtr.html" class="facebook-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
		</span>
	</a>
    
	<a href="https://plus.google.com/share?url=http://localhost:4000/cpp/cpp-SmartPtr.html" class="googleplus-share">
		<span class="fa-stack fa-lg">
			<i class="fa fa-circle fa-stack-2x"></i>
			<i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
		</span>
	</a>
</div>
-->

<div id="disqus_thread"></div>


 
</div>


</article>

        </div>

    </body>

<footer class="site-footer">
    <div class="wrapper">
        <center>
            <p>
                <a class="link" href="/%20/">Home</a> /
                <a class="link" href="/archive/">Archive</a> /
                <a class="link" href="/category/">Category</a> /
                <a class="link" href="/tags/">Tags</a> /
                <a class="link" href="/about/">About</a> /
                <a class="link" href="/contact/">Contact</a>
            </p>
            <span><script>document.write(new Date().getFullYear());</script></span>
            <span>&copy;</span>

            <a href="mailto:sol.rosca@gmail.com?subject=Hello&nbsp;RoscaS"> RoscaS</a>
            <br>
        </center>
    </div>
</footer>

<foot>
    <foot>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Derictory -->

  <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
  <script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>

<!-- Hit analytics -->

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- Directory -->

<script src="/js/main.js"></script>

</foot>

</foot>

</html>
